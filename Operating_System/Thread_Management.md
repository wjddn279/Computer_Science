

# Thread Management

- 프로세스와 스레드
  - 하나의 프로세스 안에 여러개의 스레드가 가능
  - 프로세스 : resource를 제어
  - 스레드 : 프로세스의 제어 역할 (여러개 가능), 프로세스가 할당 받은 자원을 공유

## 프로세스 vs 스레드

- 프로그램이 돌아가고 있는 상태 -> 프로세스

- 한 프로세스 내에도 여러개의 작업들이 동시에 진행 될 필요가 있다. 그 갈래 -> thread

- 컴퓨터는 프로세스 마다 자원을 나눠서 사용 (컴퓨터의 자원을 분할해서 사용)
- 스레드는 프로세스 마다 주어진 전체 자원을 나눠서 사용
- 

![image-20200918194745784](images\image-20200918194745784.png)

![image-20200918195035816](images\image-20200918195035816.png)

- 프로세스의 resource를 공유하고 스레드 마다 개인적인 공간을 만든다
- 각기 다르게 resource를 제어

![image-20200918195238897](images\image-20200918195238897.png)

## 스레드 (Thread)

- Light Weight Proceess (가벼운 프로세스) -> 스레드는 자원을 공유해서 사용하기 때문에 가볍다
- 프로세서 활용의 기본 단위
- 구성요소
  - Thread ID
  - Register set (PC, SP)
  - Stack (local data 등)
- 제어 요소 외 코드, 데이터 및 자원들은 프로세스 내 다른 스레드들과 공유
- 전통적 프로세스 = 단일 스레드 프로세스

## 스레드의 장점

- 사용자 응답성 
  - 일부 스레드의 처리가 지연되어도, 다른 스레드는 작업을 계속 처리 가능
  - 게임 모니터, 마우스, 헤드셋의 예제
- 자원 공유
  - 자원을 공유해서 효율성 증가 (커널의 개입을 피할 수 있다.)
  - 프로세스가 여러개 라면? 자원의 사용 때문에 context switch가 빈번하게 발생
  - but 스레드는 자원을 공유하기 때문에 context switch가 적어짐, 효율성 증가

- 경제성
  
  - 프로세스의 생성, context switch에 비해 효율적
- 멀티 프로세서 활용
  
- 병렬처리를 통해 성능 향상 (cpu 코어 여러개 사용 가능)
  
- 스레드 사용의 예
  - 게임을 한다고 가정해보자
  - 모니터, 마우스, 헤드셋이 필요하다고 가정
  - 스레드가 1개인 프로세스 
    - i/o가 발생하면 run -> block 상태로 이동
    - 마우스 클릭을 하면 모니터 화면이 안나옴, 즉 하나의 작업 중 다른것 못함
  - 스레드가 여러개인 프로세스
    - 자원을 공유해서 사용하여 동시에 마우스,키보드,모니터 입력 처리
    - 사용자 응답성의 증가

   ## 사용자 수준 스레드 (User Thread) 다대일 (n:1) 모델

- 사용자 영역의 스레드 라이브러리로 구현 됨
  - 스레드의 생성, 스케출링 등
  - POSIX threads, Win32 threads
- 커널은 스레드의 존재를 모름
  - 커널의 관리(개입)을 받지 않음
    - 생성 및 관리의 부하가 적음, 유연한 관리 기능
    - 이식성이 높음
  - 커널은 프로세스 단위로 자원 할당
    - 하나의 스레드가 block 상태가 되면, 모든 스레드가 대기
- 사용자 수준 스레드
  - 사용자 영역에서 thread를 나눠서 사용
  - 결과적으로 커널에서는 한개의 thread 만 사용되는 구조
  - 단점: 하나의 user thread가 block 되면 모든 user thread 가 block 상태

![image-20200918201536790](images\image-20200918201536790.png)

## 커널 수준 스레드 (Kernel Thread) 일대일 (1:1) 모델

- os(kernel)가 직접 관리
- 커널 영역에서 스레드의 생성, 관리 수행
  - context switching 등 overhead가 큼
- 커널이 각 스레드를 개별적으로 관리
  - 프로세스 내 스레드들이 병행 수행 가능
    - 하나의 스레드가 block 상태가 되어도 다른 스레드는 계속 작업 수행 가능

![image-20200918201840304](images\image-20200918201840304.png)

## 혼합형 (n:m) 스레드

- 사용자 수준 스레드와 커널 수준 스레드를 섞어 장점만 취함

- n개의 사용자 수준 스레드 - m개의 커널 스레드 (n>m)
  - 사용자는 원하는 수 만큼 스레드 사용
  - 커널 스레드는 자신에게 할당된 하나의 사용자 스레드가 block 상태가 되어도, 
  - 다른 스레드 수행 가능

![image-20200918202253614](images\image-20200918202253614.png)
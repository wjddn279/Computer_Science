## Vue.js란 무엇인가?

MVVM 패턴의 ViewModel 레이어에 해당하는 화면단 라이브러리

![image-20201109113151074](.\image-20201109113151074.png)

- View -> DOM , Model -> Plain JS Objects , ViewModel -> Vue
- View(HTML)에서 변경된 사항을 ViewModel에서 관리하여 Model(js 객체)에 전달함
  - 기존에는 parsing등으로 직접 접근해서 관리해야 했지만 자동으로 해줌
- 데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API를 지원하는데에 궁극적인 목적이 있음
- Angular에서 지원하는 양방향 데이터 바인딩을 동일하게 제공
- 하지만 컴포넌트 간 통신의 기본 골격은 React의 단방향 데이터 흐름 (부모->자식)을 사용 (Props/Emit)
- 다른 프론트엔트 프레임워크에 비해 상대적으로 가볍고 빠름
- 문법이 단순하고 간결하여 초기 학습 비용이 낮고 쉽게 접근 가능

## MVVM 패턴

Backend 로직과 Client 의 markup & 데이터 표현단을 분리하기 위한 구조

전통적인 MVC 패턴의 방식에서 기인된 것이다.

간단히 화면 앞단의 화면 동작 관련 로직과 뒷단의 DB 데이터 처리 및 서버 로직을 분리하고 뒷단에서 넘어온 데이터를 Model에 담아 View로 넘겨주는 중간 지점으로 이해 가능하다.

![image-20201109113754426](.\image-20201109113754426.png)

- View -> 유저 인터페이스 , ViewModel -> 상태관리/연산수행, Model -> 비즈니스 데이터
- Model이 비즈니스 데이터를 관리하다가 값이 변경되면 ViewModel에게 변경사항을 알린다.
- ViewModel은 Model의 변경 내용을 화면인 View에게 알려서 반영하므로 사용자가 내용을 확인할 수 있게 한다.
- View를 보던 사용자가 어떤 입력 값을 변경하면 ViewModel에게 데이터 바인딩에 대한 요청을 보낸다.
- ViewModel은 실제 Model의 값을 변경하면서 데이터 일관성을 유지한다.

## Virtual DOM

웹 페이지가 화면에 렌더링 되기까지의 과정

![image-20201109121708428](.\image-20201109121708428.png)

DOM 요소가 많아지고 복잡해 질수록 빨간색 박스의 Render Tree를 만드는 횟수가 증가하고 무거워 진다. 따라서 DOM에 작은 수정이 생길 때 마다 Expensive한 렌더링 과정이 반복되므로 부하가 증가한다.

하지만 가상 DOM은 JS 객체의 일종으로 메모리상에서 관리되기 때문에 실제 렌더링이 일어나지 않는다. 따라서 가상 DOM을 업데이트 하는데에는 비용이 거의 들지 않는 장점이 있다.

![image-20201109123701293](\image-20201109123701293.png)

HTML을 파싱하여 DOM Tree 구성 , CSS를 통해  Style Rule 구성

둘을 조합하고 inline style을 읽어와 Render Tree 구성 

페인팅(렌더링) 과정을 거쳐 사용자에게 display

![image-20201109124442612](.\image-20201109124442612.png)
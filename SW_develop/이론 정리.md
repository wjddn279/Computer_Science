## RESTful API

REST란 Representational State Transfer의 약자로서, 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능하게끔 설계 하는 것 입니다.

http 통신에서 사용되며 보통 구분을 uri와 method로 기능을 구분합니다.

RESTful API란 이런 REST한 특성을 잘 지키도록 설계된 API라고 말씀드릴 수 있겠습니다.

따라서 RESTful API는 요청을 보내는 주소와 형식만 보더라도 이것이 무엇을 위한 요청인지 파악이 가능하게끔 하는 것 입니다.

### API란?

소프트웨어가 다른 소프트웨어로부터 지정된 형식으로 요청, 명령을 받을 수 있는 수단

## 비동기 프로그래밍

멀티 스레드를 사용하여 병렬적으로 처리하는 프로그래밍

## Axios 란?

우선, promise는 자바스크립트 비동기 처리에 사용되는 객체 입니다.

3가지 상태로 구분이 가능한데, 대기 이행 실패 3가지 상태로 나뉩니다.

대기는 비동기 처리 로직이 완료되지 않은 상태, 이행은 완료되어 결과 값을 반환해준 상태,

실패는 오류가 생겨 실패한 상태 입니다. 이행이 완료되었을 때, .then 으로 응답값을 기반으로 콜백 함수를 실행 시킬 수 있습니다.

axios는 그 promise를 기반으로 http 통신을 하는 것이고, 보통 요청을 보낼 때 사용합니다.

axios의 promise 이행의 결과값은 http 응답 값이고 이를 기반으로 콜백 함수를 실행합니다.

## HTTPS 동작 원리

기존 HTTP의 문제점은 서버와 클라이언트 간의 전송 경로가 도청당할 수 있다는 점, 그리고 접속하려는 사이트가 피싱 사이트인지 구분하기가 힘들 다는 보안 문제가 있었습니다.

이러한 보안 문제를 해결하기 위해 HTTPS 프로토콜을 사용하기 시작했습니다. HTTPS의 보안은 TCP의 3way-handshaking 과정에서 이루어집니다. 공개키 비공개키를 혼합한 방식과 인증서를 활용한 방법으로 연결 수립과정을 암호화 하여 보안성을 높입니다.

## 자바스크립트 1급 객체

우선, 1급 객체란 1급 시민의 조건을 만족시키는 객체라고 할 수 있습니다.

1급 시민의 조건은 3가지가 있습니다. 첫번째, 변수나 데이터에 할당이 가능해야 한다. 두 번째, 객체의 인자로 넘길 수 있어야 한다. 세 번째, 객체의 리턴값으로 리턴 할 수 있어야 한다. 입니다.

## Vue watch vs computed 차이

computed는 참조하고 있는 값이 변경될 때 마다 정의된 계산식에 따라 값을 출력하는 것 입니다.

이와 다르게 watch는 값이 변경될 때 실행되는 함수를 임의로 지정할 수 있습니다. 즉, computed가 계산된 값을 출력하는 용 이라면, watch는 특정 조건에서 함수를 실행 시키기 위한 트리거로 사용할 수 있다는 의미 입니다.

쉽게 말해 computed는 무언가 특정 값을 return 하는 것 이고, watch는 특정 함수를 실행 시킨다는 관점에서 차이가 있습니다.

## MVVM 패턴

MVVM  은 디자인 패턴 중 하나로서, Vue.js의 디자인 패턴이기도 합니다. 우선 MVVM은 각각 Model, View, ViewModel 3가지로 구성이 되어있습니다. View는 UI에 관련된 것을 다룹니다. 사용자가 스크린을 통해 보는 것에 대한 구조를 정의 합니다. Model은 어플리케이션에서 사용할 데이터에 관련된 행위와 데이터를 다루는 부분 입니다. ViewModel은 View와 Model의 중간자로서, View와 Model 데이터 사이의 데이터 바인딩을 전달하며 명령을 통해 모든 UI 행동을 컨트롤 합니다.

### DOM vs Virtual DOM

DOM 조작의 문제는 각 조작이 일어날 때 마다 트리 변화와 렌더링을 일으킨다는 것 입니다. 하지만 가상 DOM은 재 렌더링지 않고 변경사항을 처리하기 때문에 연산 비용이 적이진다.

하지만 이러한 과정은 가상DOM 없이도 가능하다(add와 같은 연산). 그럼에도 가상DOM을 활용하는 이유는 그 DOM fragement를 관리하는 과정을 자동화하고 추상화 함에 있다. 또한 어떤 값이 바뀌었는지 자동으로 감지하기 때문에 편리하다.

## 프레임 워크 vs 라이브러리

프레임워크는 내가 프레임워크의 형식에 맞춰 개발을 하는 것

라이브러리는 내가 개발하는 과정에 라이브러리를 불러와서 사용하는 것.

vue예시 vue-cli로 활용하면 프레임 워크 vue객체를 만들어 자바스크립트 개발에 사용하면 라이브러리

## 데이터 베이스

### DBMS란?

다수의 컴퓨터 사용자들이 컴퓨터에 수록 된 수 많은 자료들을 쉽고 빠르게 추가, 수정, 삭제 할 수 있도록 지원하는 시스템입니다. 데이터 베이스 내의 정보를 검색하거나 정보를 저장하기 편리하고 효율적인 환경을 제공하는 것이 목적 입니다. 대표적인 기능은 정의, 조작, 제어 세 가지가 있습니다.

### RDBMS란?

관계형 데이터베이스 관리 시스템 입니다. 관계형 데이터 베이스를 관리하기 위한 시스템을 의미하며 모든 데이터를 2차원 테이블로 표현합니다. 그리고 그 테이블간의 관계를 정의하는 것이 관계형 데이터 베이스 입니다. 대표적인 시스템으로는 Oracle, MySQL 등이 있습니다.

### 정규화란?

정규화란 데이터베이스의 중복성을 줄이고 삽입, 삭제, 갱신 시 이상현상을 방지하기 위해 데이터베이스를 작은 단위로 나누는 것을 의미 합니다. 정규화를 함 으로서 저장공간을 효율적으로 사용하고 데이터의 무결성을 유지하며, 안정성을 최대화 하는 이점을 가집니다. 하지만 너무 작은 단위로 나눔으로서 데이터 조회시 JOIN연산이 자주 발생하고, 이는 검색 속도를 늦추기 위해 일부로 정규화된 데이터 베이스를 다시 합치는 반정규화 라는 것도 존재 합니다.

### 데이터베이스 키의 종류

1. 후보 키 : 최소성과 유일성을 동시에 만족하는 속성, 유일성은 특정 키로 모든 데이터를 구분 할 수 있는 것 입니다. 최소성은 그 유일성을 만족하는 키 중 최소한의 단위로 구성되어 있는 것을 의미 합니다.
2. 기본 키 : 후보 키 중 하나를 선택 한 것 이며, 기본 키를 기준으로 모든 데이터를 구분 합니다.
3. 대체 키 : 후보 키중 기본 키가 아닌 후보 키
4. 슈퍼 키 : 유일성은 만족 시키 지만, 최소성을 만족시키지 않는 속성
5. 외래 키 : 다른 테이블의 기본키를 참조 하는 속성, 다른 테이블과의 관계를 정의한다.

### 트랜잭션

트랜잭션이란 데이터 베이스를 변화시키는 하나의 동작 단위입니다.

이 트랜잭션은 4가지 성질이 있는데 앞글자를 따서 ACID라고 하기도 합니다.

A 원자성은 특정 트랜잭션은 db에 반영되거나 전혀되지않거나 둘 중 하나만 해야 하는 것 입니다.

C 일관성은 트랜잭션 이후에도, 데이터베이스는 일관된 상태를 유지 해야 한다는 점 입니다.

I 고립성은 수행중인 트랜잭션이 완료되기 전 까지 다른 트랜잭션이 참조 할 수 없다는 점 입니다.

D 영속성은 성공으로 완료된 트랜잭션은 영구적으로 그 결과가 반영이 되어야 한다는 점 입니다.

### NOSQL

관계형 데이터 베이스는 테이블이란 단위로 키와 값의 관계에 의해 구성된다.

하지만 비 관계형 데이터 베이스는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는다.

저장되는 데이터 형식의 특정 요구사항에 맞게 최적화된 모델을 사요하는 것이 특징입니다.

장점은 가변적인 데이터 구조로 데이터를 저장할 수 있어 유연성이 높은 데이터베이스 설계가 가능하다는 점 입니다. 단점으로는 복잡한 쿼리가 불가능하고 일관성을 항상 보장할 수 없다는 점이 있습니다.

 ### 인덱스

데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조 입니다.

인덱스를 설계함 으로서 데이터베이스 조회시간을 단축시킬수 있습니다.

인덱스는 클러스티드 인덱스와 논클러스티드 인덱스로 나뉘는데, 

클러스티드 인덱스는 인덱스 키에 따라 데이터가 정렬되어 저장되는 방식 입니다.

실제 데이터가 정렬되어 있어 인덱스를 검색하지 않아도 빠르게 찾을 수 있지만 삽입, 삭제 연산시 과정이 복잡해 집니다.

논클러스티드 인덱서는 키 값만 정렬되어있을 뿐 실제 데이터는 정렬되지 않는 방식 입니다.

** 클러스티드는 실제 값 정렬, 논클러스티드는 실제 값 정렬 X**

### VIEW

사용자에게 접근이 허용된 자료만을 보여주기 위해 실제 데이터 베이스에서 유도된 가상의 테이블 입니다. 뷰는 저장 장치에 물리적으로 존재 하지는 않지만 사용자에게는 실제로 있는것 처럼 보여집니다. 이로서 데이터의 논리적인 독립성을 제공 할 수 있고 특정 데이터만 보여줌으로서 보안관리에 용이 합니다.

## 프로그램 vs 프로세스 vs 스레드

프로그램 : 작업을 위해서 실행할 수 있는 파일 (어플리케이션)

프로세스 : 실행되고 있는 컴퓨터 프로그램

- Register, Counter, Stack : 지역 변수, 함수 인자, 함수 리턴 값 등 저장(일시적)
- Heap : 동적으로 할당 가능한 
- Code : 실제 실행되는 코드

스레드 : 프로세스의 실행 단위

- 프로세스의 자원을 공유하면서 동시에 각기 다른 작업
- Code, Data, Heap은 공유
- Stack은 각기 다른 역할

## Get vs Post

두개 다 클라이언트에서 서버로 요청시 그 방식을 정의하는 것이다.	

- Get
  - 데이터를 전달 할 때, 주소 뒤에 이름과 값이 결합된 쿼리스트링 형태로 전달
  - Post 방식 보다 상대적으로 전송속도가 빠르다.
  - 하지만 쿼리스트링이 그대로 url에 노출되기 때문에 보안성이 떨어진다.
  - 길이에 제한이 있다.
  - 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용
- Post
  - 주소창에 쿼리스트링 정보가 노출되지 않아 보안성이 높다
  - 일정 크기 이상의 데이터를 보내야 할 때 사용한다.
  - 전송속도가 get방식에 비해 느리다.
  - 웹 브라우저가 웹 서버에 데이터를 전달할 때 사용

## Session vs Cookie

- HTTP 의 특징 
  - Stateless -> 이전의 응답 요청을 서버는 기억하지 않는다.
  - 따라서 현재 상태를 저장하기 위한 방법이 필요(ex 로그인 상태)
  - 특정 방문자가 머무르고 있는 동안 상태를 지속시키기 위한 방법 -> 쿠키,세션

- Session
  - Session에 관련된 데이터는 서버에 저장된다
  - 따라서 보안성이 높다
  - 하지만 과도하게 많은 경우 서버의 자원을 많이 사용하는 단점
- Cookie
  - 서버가 아닌 client에 텍스트 파일로 저장
  - 정보 유출이 가능하고 보안성이 낮다

## MVC 패턴

사용자 인터페이스로 부터 개발하는 부분을 완전히 분리 해놓은 형태

개발 테스트, 유지를 독립적으로 수행할 수 있게 한다.

- Model 
  - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현
  - 어플리케이션의 데이터를 관리. 주로 VIEW로 정보를 전달 받고, Controller로 부터 상태 변화에 대한 지시를 받는다
- View 
  - 사용자 인터페이스 내의 구성요소들을 표현 (사용자에게 보여지는 화면)
  - 모델의 데이터를 사용자 인터페이스 같은 적절한 형태로 표현한다.
- Controller 
  - Model과 View를 연결하고 있는 클래스를 대표 
  - Model과 View 내의 클래스들 간 정보 교환하는데 사용
  - 사용자의 입력값을 받고 이를 바탕으로 모델 객체에 지시를 내린다.

## 메인 메모리의 영역

- 코드 (code) 영역: 프로그램의 소스 코드가 저장되는 영역이다. CPU는 코드 영역에 저장된 명령어(소스, 함수, 제어문)를 가져와서 처리한다.

  -> 소스 코드가 저장된 영역

- 데이터 (data) 영역: 전역 변수와 정적 변수가 저장되는 영역이다. 프로그램 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.

  -> 메인함수에서 선언한 변수들이 저장된 영역

- 스택 (stack) 영역: 프로그램이 사용하는 임시 메모리 영역이며 함수의 호출과 관계되는 지역 변수와 매개 변수가 저장되는 영역이다. 함수 호출 구조가 자료구조 stack과 동일하다. 따라서 재귀 함수 호출 시, 너무 많은 깊이로 들어가면 stack 메모리가 부족한 stack overflow가 발생한다.

  -> 함수의 인자, 지역 변수, 반환 값 등을 저장하는 영역

- 힙 (heap) 영역: 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 영역이다. 즉, 동적 할당을 통해 생성된 동적 변수를 관리하기 위한 영역이다. (malloc)

  -> 사용자가 임의로 할당하는 메모리 영역

## Garbage Collector (GC)

Garbage란 정리되지 않은 메모리, 즉 유효하지 않은 객체의 메모리를 뜻한다. 

따라서 Garbage Collector는 메모리가 부족할 때, 가비지들을 메모리에서 해제하는 기능을 뜻한다.

```java
int[] array = new int[3];
arr[0] = 0;
arr[1] = 10;
String[] array = new String[5]  # 기존 array의 객체는 Garbage가 됨 (아무도 참조 x)
```

Garbage 객체 판별 -> Reachability 개념 사용

어떤 객체에 유효한 참조의 여부에 따라 Reachability / Unreachability 로 구별

객체를 저장하는 메모리 공간을 Yong generation 과 Old generation으로 나눈다.

- Young generation: 새롭게 생성한 객체의 대부분이 young generation에 위치한다. 대부분의 객체가 금방 unreachable 상태가 되기 때문에 young generation에 생성되었다가 GC를 통해 사라진다. 이를 Minor GC가 발생한다고 함.
- Old generation: 접근 불가능 상태로 되지 않아 young generation에서 살아남은 객체가 old generation으로 복사된다. Minor GC만으로 확보한 메모리 공간이  부족할 때, old generation에서 GC 실행. 이를 Major GC라고 함.

### Reference Counting

모든 변수와 함수를 객체로 생성하며 만들 때마다 유형과 refence count가 생성

이는 객체가 참조될때 증가하고, 객체의 참조가 해제될때 감소한다. count가 0이 되면 객체의 메모리가 해제된다.

## CBV, CBR

1. Call By Value: CBV에 의한 호출 방식은 함수 호출 시 변수의 값을 복사하여 함수의 인자로 전달.복사된 인자는 함수 내에서만 사용되는 local variable의 특성을 가짐(stack에 저장). 즉 함수 안에서 인자의 값이 변경되어도 외부 변수의 값은 변경 되지 않는다.
2. Call By Reference: CBR에 의한 호출 방식은 함수 호출 시 변수의 주소 값을 복사하여 함수의 인자로 전달한다. 따라서 함수 안에서 값이 변경 되면 전체 코드의 해당 변수의 값이 변경 된다.
3. Call By Assignment(python): CBA는 전달 받는 객체에 따라 참조 방식이 결정된다. immutable object(inf,float,tuple)이 인자일 때는 CBV, mutable 하면 CBR로 전달 된다.